有些时候我们并不能一味的遵循先来后到的原则,因此需要堆来实现顺序的调整
这是一种给优先队列

1.模型(时刻告诉自己是树来形象数组来实现(优先队列,即使不是尾进首出也同样需要先这么做然后调整))
#优先队列是允许插入和删除最小者的(目的是为了找出并且删除最小者)
#不断地查找不断地删除

2.一些简单的实现
#使用链表,这将使得查询效率极低但是删除效率较高
#使用树,但是一直在使用最小值删除,会导致严重的破坏平衡,而查找树又具有太多不必要的功能
#虽然我们使用的是基本的数据结构,但是进行合并需要复杂的操作,因此链的使用是跑不掉的

3.二叉堆
同二叉树一样,堆必须不断的维持堆序性和结构性(事实上这并不难做)
#结构性质:堆是一个被完全填满了的二叉树(唯一的例外是在底层)
         每一层都是从左到右(正因如此可以用一个数组来表示而不是用链)
         因此堆是由一个对象数组和一个代表堆大小的整数组成(只需要删除最小元素,因此增删问题特岛解决)
画成树有利于观察,而实际情况下的实现却是使用了数组
#堆序性质:因为要保证快速执行,因此要把最小元素放在根的位置上

4.优先队列的应用(图论问题留到第七章解答)
#选择问题:1A和2B排序在稍坏的情况下都是O(N平方)的运行时间
         6A则是通过构造一个堆来进行k次删除最小值,通过计算运行时间主要是堆的构造为O(N)
         6B算法则是通过堆来实现2B算法(上滤)
#事件模拟:可以因此安排人手

5.d堆
#就如同二叉树和b树的差距一样,实际运用中是4-堆战胜了二叉堆
#复杂的数据分析留到11章之后

6.左氏堆(这里就必须当成二叉树来搞了(因为涉及到了递归))(因为十分有利于合并)
#左氏堆的性质是:左儿子的零路径长至少要与右儿子的零路径长相等(这使得难以维持完全二叉树)
#左氏堆的操作:插入可以看成一个特殊的合并
#显然我们可以使用一个链接构建的二叉堆来以O(N)的事件来构建一个左氏堆

7.斜堆(是左氏堆的自调节形式)
#二者的关系就是伸展树和平衡树的关系
#因为是无条件的调整,因此可以取消掉深度的数据储存
#具有堆序性(最坏情况好于左氏堆)
#前面与左氏堆一样,然后每次直接交换左右堆

8.二项队列
#是堆序树(二项树)的集合
#可以用二进制极为方便的表示(k代表位数)
#就是不断地拆和和
