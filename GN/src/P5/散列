1.一般想法(通过取模判断是否冲突)(散列可以看作一个过程)
#散列是支持常数事件的增删改查,但是不支持有任何排序信息的操作
#查找是根据关键字的
#每个关键字背映射到一个范围中的某个数,并且被放到适当的单元中.这样的映射就叫做"散列"
#但是当散列存在一个要解决的问题:两个关键字散列到同一个值的时候

2.散列函数(根据算法挖一块给关键字)(取余速度最快)(因为是通过算法转化为的索引,那么如果余是相等的就会发生冲突)
#要尽量保证表的大小是素数(如果表大小和关键字重复了,那么将毫无意义)(后面插入的时候会造成麻烦)
#关键字是拿来拆的(孤弱关键字是String的时候,会用Unicode的值加起来)分配是取余(这样分配不均)
#同时也要让关键字范围比内容最大值大不了太多(散列函数允许溢出,就会引进负数)
#可以根据散列大小和关键字长度来改变选择
#溢出的时候就是使用负数的时候了
(探测出来的索引就是)

3.分离链接法
#将相同的元素保存到一个双向链表之中
#新插入的元素最好放在前端,因为意味着很可能立马就会使用
#自定义的条件经过hash算法得到的int值通过自定义的myhash()方法转化为一个数组下标,该下标就是存储"相同"元素的链表(正式因为如此才存在hash碰撞)

4.探测散列表(如果不用惰性删除,那么即使后面元素存在依然无法得到存在的结果)
#链表在新单元分配内存会消耗时间,特别是在其他语言会尤为明显,同时需要用到第二种数据结构
#因此可以寻找新的单元
#也是因此填装因子更小大概0.5
#会不断开辟新的空间
#线性探测:一个一个排查(在一半以上被填入了之后效率便不可取了)
#平方探测法:以平方的形式跳跃排查(如果表的大小不是素数,且插入过半之后,就会造成找不到表插入的情况)
(k+3)和i方
二次聚集比一次聚集更收敛
#双散列:虽然在理想状态下很具有吸引力,但是性能始终是一个坎(表的大小不是素数那么可能导致提前用完)
其实就是一个复合函数

5.再散列:以新的散列表(更大)来

6.标准库中的散列表
#是以hashset和hashmap形式
#不关心有序方式查看,有三种映射:单词长度,代表,单词(关键字)
#散列表中hashcode的计算就是运行速度最大的阻碍,因此String类型对其进行了优化,会短暂记住这个结果
#虽然都会记住,但是不同的对象即使拥有相同的对象也要单独计算,因此只有在再散列等对同一个String类型多次访问的时候有用,上述三种映射中用处不大

7.最坏情形下的访问散列表
#即使填装因子为1,也不能保证表不冲突,这是一个期望的问题
#可以通过多表的形式来缩短表的长度(但是可能造成表过多,还是有可能发生冲突)
#第二种问题可以通过清表+换函数的方式解决
#至于数量,则要保证为元素个数的平方,因此一种方式诞生了:只要将冲突的散列改成一个n方的二级散列就行了
#布谷鸟散列:运用了"更小界" 就是把自己的孩子租借给别人

8.跳房子散列
#是线性探测的延申,因为无论怎样探测只要从散列起始开始探测,那么都会有一次二次聚集.因为相邻位置比额外的探测更加具有优先性,因此线性探测还是有必要的
#是一种跳跃的思维并用各个位的0或者1来记录其是否被占用,一旦个位为1之后,该Hop便不可再移动了,因为即使前三位是0,那也是因为跳到了各位而这三位被占用导致的
#卡住了再散列是个麻烦

9.通用散列法
#散列的增删改都是线性的,但是受到以下两个因素的限制:
散列函数必须是常熟时间计算
散列函数必须均匀分布在数组单元中
(通用散列就能解决以上问题)(除非是遭受到了不能容忍的原因:黑客入侵)
可通过以下定理来限制一个通用散列函数:对于任意x != y,H中有h(x) = h(y)的散列函数h的个数至多为|H|/M个
                               对于任意xn != yn,H中有h(x1) = h(y1)......的散列函数h的个数至多为|H|/M平方 个
                               (具体设计翻书P147)

10.可拓散列
#为了解决处理数据量太大装不进主存的情况
#如果用分离链表或者探测散列,那么就会在冲突的时候引发多个区块被检查,过大的时候还会执行代价颇大的再散列
#有点索引的味道
#比特时完全随机的
#发现树叶的期望个数和b树是相似的