1.一般想法(通过取模判断是否冲突)(散列可以看作一个过程)
#散列是支持常数事件的增删改查,但是不支持有任何排序信息的操作
#查找是根据关键字的
#每个关键字背映射到一个范围中的某个数,并且被放到适当的单元中.这样的映射就叫做"散列"
#但是当散列存在一个要解决的问题:两个关键字散列到同一个值的时候

2.散列函数(根据算法挖一块给关键字)(取余速度最快)(因为是通过算法转化为的索引,那么如果余是相等的就会发生冲突)
#要尽量保证表的大小是素数(如果表大小和关键字重复了,那么将毫无意义)(后面插入的时候会造成麻烦)
#关键字是拿来拆的(孤弱关键字是String的时候,会用Unicode的值加起来)分配是取余(这样分配不均)
#同时也要让关键字范围比内容最大值大不了太多(散列函数允许溢出,就会引进负数)
#可以根据散列大小和关键字长度来改变选择
(探测出来的索引就是)

3.分离链接法
#将相同的元素保存到一个双向链表之中
#新插入的元素最好放在前端,因为意味着很可能立马就会使用
#自定义的条件经过hash算法得到的int值通过自定义的myhash()方法转化为一个数组下标,该下标就是存储"相同"元素的链表(正式因为如此才存在hash碰撞)

4.探测散列表
#链表在新单元分配内存会消耗时间,特别是在其他语言会尤为明显,同时需要用到第二种数据结构
#因此可以寻找新的单元
#也是因此填装因子更小大概0.5
#会不断开辟新的空间
#线性探测:一个一个排查(在一半以上被填入了之后效率便不可取了)

#平方探测法:以平方的形式跳跃排查(如果表的大小不是素数,且插入过半之后,就会造成找不到表插入的情况)
(k+3)和i方
二次聚集比一次聚集更收敛

#双散列:虽然在理想状态下很具有吸引力,但是性能始终是一个坎(表的大小不是素数那么可能导致提前用完)
其实就是一个复合函数
5.再散列:以新的散列表(更大)来
