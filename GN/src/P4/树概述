1.这种数据结构叫做树
2.其优越性在于绝大部分操作都是O(NlogN)
3.树的一种自然定义方式是递归
4.没有儿子的节点称作"树叶"
5.从根到节点的路径长度叫做深度
6.树的实现:
#可以儿子链接一个儿子,然后该儿子通过一条链链接各个兄弟
class TreeNode{
    Object element;
    TreeNode firstChild;
    TreeNode nextSibling;
}

7.树的应用
#系统中文件夹的存放
分为三种:(拆分整体的思想)
先序:根左右
中序:左根右
后续:左右跟

8.二叉树的实现(有些类似于双向链表)
class BinaryNode{
    Object element;
    BinaryNode left;
    BinaryNode right;
}
如同表达式树:中序后序的遍历(只有树叶是数,其余全是运算符)
中序就是我们正常人一般使用的思路的中缀表达
后序就是上一章我们对栈的应用中的后缀表达
构造表达式树就是数压运算符就形成根

9.二叉查找树ADT
采用的右根左
为了保证简单化,我们可以实现一个Comparable接口,保证能够使用compareTo()方法进行排序

10.AVL树(带有平衡条件)
由于二叉树在多次增删改查的操作之后,会出现左子树的深度大于右子树
因此AVL树应运而生
它只保证了树两边深度相同,且深度为O(logN),并没要强求树的深浅
为了防止插入对平衡树的影响,我们通过旋转来纠正

11.伸展树
有时会连续访问二叉树深层元素,这使得每一次都会有较大的开销
#旋转:通过每一次访问都将该元素同父类进行一次旋转,这样访问该元素的开销确实变小了,但是相应的,对于另外的元素就会极大的加深他的深度
导致如果要访问该元素的话,开销反而增大了
#展开:思维方式和旋转是类似的,但是在旋转的实施上有些选择的余地.有两种情况,之字形和一字形,二者结合使用
一字型,将全部颠倒,查询元素的元素给予最近元素,且左右颠倒
之字形,就是双旋转啊
总之,该树虽然结构上被破坏了,并且结构一直在变化,但是就算是删除操作,只要旋转下去便会方便许多

12.再探树的遍历
还是那三个遍历方法,以递归的形式来呈现
中序:可以保证元素按照顺序输出
后续:是用来计算高度的
前序:可以标记每一个节点的深度
层序遍历(要用到队列)

13.B树
当把数据结构放在磁盘上时,大O模型将不再适用(因为该模型是假设所有操作的时间都是相等的)
正是因为磁盘的访问代价太高了,因此只需要将磁盘的访问次数给降低至原来的一半,那么整体的访问时间也将变为原来的一半左右
而二叉树如果最坏情况下具有线性的深度,那么磁盘的访问次数将会很多
因此需要更多的分支,从而减小深度(但是一定要得到平衡条件,否则会退化成为一个链表)
当存储位置不够时:可以向上分裂(这可能导致树的深度增加)
              可以通过寄养的方式,这样使得树更趋向于饱和,从而在有些时候更节省内存
当删除的时候:可以联合成一个新的页
           也可以寄养




