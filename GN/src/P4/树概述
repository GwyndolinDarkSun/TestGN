1.这种数据结构叫做树
2.其优越性在于绝大部分操作都是O(NlogN)
3.树的一种自然定义方式是递归
4.没有儿子的节点称作"树叶"
5.从根到节点的路径长度叫做深度
6.树的实现:
#可以儿子链接一个儿子,然后该儿子通过一条链链接各个兄弟
class TreeNode{
    Object element;
    TreeNode firstChild;
    TreeNode nextSibling;
}

7.树的应用
#系统中文件夹的存放
分为三种:(拆分整体的思想)
先序:根左右
中序:左根右
后续:左右跟

8.二叉树的实现(有些类似于双向链表)
class BinaryNode{
    Object element;
    BinaryNode left;
    BinaryNode right;
}
如同表达式树:中序后序的遍历(只有树叶是数,其余全是运算符)
中序就是我们正常人一般使用的思路的中缀表达
后序就是上一章我们对栈的应用中的后缀表达
构造表达式树就是数压运算符就形成根

9.二叉查找树ADT
采用的右根左
为了保证简单化,我们可以实现一个Comparable接口,保证能够使用compareTo()方法进行排序

10.AVL树(带有平衡条件)
由于二叉树在多次增删改查的操作之后,会出现左子树的深度大于右子树
因此AVL树应运而生
它只保证了树两边深度相同,且深度为O(logN),并没要强求树的深浅
为了防止插入对平衡树的影响,我们通过旋转来纠正

11.伸展树
有时会连续访问二叉树深层元素,这使得每一次都会有较大的开销
#旋转:通过每一次访问都将该元素同父类进行一次旋转,这样访问该元素的开销确实变小了,但是相应的,对于另外的元素就会极大的加深他的深度
导致如果要访问该元素的话,开销反而增大了
#展开:思维方式和旋转是类似的,但是在旋转的实施上有些选择的余地.有两种情况,之字形和一字形,二者结合使用
一字型,将全部颠倒,查询元素的元素给予最近元素,且左右颠倒
之字形,就是双旋转啊
总之,该树虽然结构上被破坏了,并且结构一直在变化,但是就算是删除操作,只要旋转下去便会方便许多

12.再探树的遍历
还是那三个遍历方法,以递归的形式来呈现
中序:可以保证元素按照顺序输出
后续:是用来计算高度的
前序:可以标记每一个节点的深度
层序遍历(要用到队列)

